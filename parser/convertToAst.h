#pragma once

#ifndef CONVERTTOAST_H
#define CONVERTOTAST_H

#define AST_NODE_VALUE 1 //Just represent a const value
#define AST_NODE_VARIABLEDECLARATION 2 // Represent a variable declaration
#define AST_NODE_ARITHMETRICEXPRESSION 3 // Present a arithmetric expression

namespace utils { template <typename> struct LinkedList; }

namespace token { struct TokensCollection; struct Token; }

namespace parser::convertToAst {

    /* Node default representation for all types of nodes 
    *   Should never be declared by it self !!
    */
    struct Node { 
        int type; // Type representation
    };

    /* Node to hold a value */
    struct NodeValue : public Node { 
        int valuePos; // Value pos in const value table 
        NodeValue(int);
    };

    /* Node to hold a variable declaration */
    struct NodeVariableDeclaration : public Node {
        int variableTypePos; // Variable type pos in const names
        int namePos; // Value pos to const names in table
        bool isPointer; // If variabled declared is pointer
        Node* valuePos; // Value assigned to this variable | NULL if no value assigned
        NodeVariableDeclaration(int, int, bool, Node*);
    };

    /* Node to hold a arithmetic expression 
    *   First and Second value can either a NodeValue or NodeArithmetricExpression
    */
    struct NodeArithmetricExpression : public Node {
        Node* frst, *scnd; // Value of first and second values 
        int expressionValue; // Expression value representation 
        NodeArithmetricExpression(Node*, Node*, int);
    };

    /* Ast */
    struct Ast {
        utils::LinkedList<Node>* body; // Hold all Nodes necessary to given TokensCollection
        utils::LinkedList<int>* keyWords; // Hold all different keywords used accross TokensCollection
        utils::LinkedList<char>* constsNames; // Hold all different constants Name accross TokensCollection
        utils::LinkedList<char>* constsValues; // Hold all different constants Values accross TokensCollection
        Ast();

        /* Set all tokens of a single instruction into the given variable
        *   @param _instrSet Instruction variable to set
        *   @param _tokensColl Tokens collection given
        *   @param _crrntTokenPos Current token position
        */
        void setFullInstruction(utils::LinkedList <token::Token>*, token::TokensCollection*, int*);

        /*  Generate a new Node
        *   @param  _instr Instruction to work with
        *   @param _instrCrrntPos Instruction current position
        */
        utils::LinkedList<parser::convertToAst::Node>* getNodes(utils::LinkedList <token::Token>*, int*); 

        /*  Generate a new Ast
        *   @param _tokensColl Tokens collection generated by the src code
        */
        void generateAst(token::TokensCollection*);


    };


}

#endif